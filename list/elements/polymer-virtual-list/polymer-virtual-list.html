<polymer-element name="polymer-virtual-list" attributes="count pageSize numPages">
  <template>
    <link rel="stylesheet" href="polymer-virtual-list.css">
    <div id="list" class="polymer-list-list">
      <div id="viewport" class="polymer-list-viewport"></div>
    </div>
  </template>
  <script>
    Polymer('polymer-virtual-list', {
      // rows per page
      pageSize: 20,
      // number of pages 
      numPages: 2,
      // total number of rows
      count: 0,
      // number of pages to render at start
      numInitialPages: 0, 
      horizontal: false,
      fixedHeight: false,
      useRaf: false,
      retainPages: false,
      observe: {
        count: 'reset',
        pageSize: 'reset',
        numPages: 'reset',
        retainPages: 'reset',
        horizontal: 'reset'
      },
      createdCallback: function() {
        this.updateMetrics();
        this.super();
      },
      ready: function() {
        this.reset();
      },
      // re-render at the top
      reset: function(count) {
        this.updateMetrics();
        this.count = count || this.count;
        this.scrollOffset = 0;
        this.$.viewport.innerText = '';
        this.pageCount = Math.ceil(this.count/this.pageSize);
        this.pageHeights = [];
        this.pages = [];
        this.rowHeight = 0;
        this.pageTops = [];
        this.$.viewport.classList.toggle('horizontal', this.horizontal);
        // TODO(sorvell): remove when event system is updated
        if (this.useRaf) {
          this.$.list.removeEventListener('scroll', this.scroll.bind(this));
          this.rafUpdate();
        } else {
          this.$.list.addEventListener('scroll', this.scroll.bind(this));
          this.scroll();
        }
      },
      updateMetrics: function() {
        var h = this.horizontal;
        this.metrics = {
          scrollOffset: h ? 'scrollLeft' : 'scrollTop',
          offsetExtent: h ? 'offsetWidth' : 'offsetHeight',
          extent: h ? 'width' : 'height',
          position: h ? 'left' : 'top'
        };
      },
      get scrollOffset() {
        return this.$.list[this.metrics.scrollOffset];
      },
      set scrollOffset(offset) {
        this.$.list[this.metrics.scrollOffset] = offset;
      },
      generatePageContent: function(page, start, end) {
        this.fire('polymer-list-generate-page', 
            {page: page, start: start, end: end});
      },
      generatePage: function(pageNum) {
        if (pageNum < this.pageCount) {
          var p = document.createElement('div');
          p.pageNum = pageNum;
          p.setAttribute('page', pageNum);
          if (this.retainPages) {
            p.style.display = 'none';
          }
          var start = p.pageNum * this.pageSize;
          var end = Math.min(start + this.pageSize, this.count);
          this.generatePageContent(p, start, end);
          this.$.viewport.appendChild(p);
          return p;
        }
      },
      setupInitial: function(pageHeight, pageNumber) {
        this.rowHeight = pageHeight/(this.pageSize < this.count ? 
            this.pageSize : this.count);
        this.viewportHeight = this.count * this.rowHeight;
        this.applyViewportHeight();
        for (var i = 0; i < this.numInitialPages; i++) {
          if (pageNumber !== i) {
            var p = this.generatePage(i);
            if (this.fixedHeight) {
              this.positionPage(p);
            }
          }
        }
      },
      measurePage: function(page) {
        var ph = this.calcPageHeight(page);
        var pn = page.pageNum;
        if (!this.rowHeight) {
          // rowHeight is not set, use the page's height to setup initial values
          this.setupInitial(ph, pn);
        }
        var ph0 = this.getPageHeight(pn);
        if (ph && ph0 != ph) {
          this.pageHeights[pn] = ph;
          // since page height has changed, invalidate all the pageTops after
          // this page
          this.pageTops.splice(pn+1, this.pageTops.length);
          // also adjust the viewport's height
          this.viewportHeight += ph - ph0;
          this.applyViewportHeight();
        }
      },
      applyViewportHeight: function() {
        this.$.viewport.style[this.metrics.extent] = this.viewportHeight + 'px';
      },
      calcPageHeight: function(page) {
        return (this.fixedHeight && this.rowHeight) ? 
            (this.pageSize * this.rowHeight) : page[this.metrics.offsetExtent];
      },
      getPageHeight: function(pageNum) {
        return this.pageHeights[pageNum] !== undefined ? 
            this.pageHeights[pageNum] : 
            this.pageSize * (this.rowHeight || 100);
      },
      getViewportPageInfo: function() {
        var c = Math.floor(this.locatePage(this.scrollOffset + 
              this.$.list[this.metrics.offsetExtent]/2) + 0.5);
        var k = c - Math.floor(this.numPages/2);
        k = Math.max(0, k);
        // the current start/center page index
        return {start: k, center: c};
      },
      locatePage: function(pos) {
        var n = pos/this.getPageHeight(0);
        if (this.fixedHeight) {
          return n;
        }
        n = Math.floor(n);
        while (n && !this.pageTops[n] || (this.pageTops[n] > pos)) {
          n--;
        }
        var p = this.pageTops[n] || 0;
        while (pos >= p) {
          p += this.getPageHeight(n++);
          this.pageTops[n] = p;
        }
        n--;
        var ph = this.getPageHeight(n);
        return n + (pos-p+ph)/ph;
      },
      positionPage: function(page) {
        var pn = page.pageNum;
        if (this.fixedHeight) {
          t = pn * this.rowHeight * this.pageSize;
        } else {
          if (this.pageTops[pn]) {
            t = this.pageTops[pn];
          } else {
            var n = 0, t = 0; 
            while (n < pn) {
              t += this.getPageHeight(n);
              n++;
            }
          }
        }
        var t0 = page.style[this.metrics.position].slice(0, -2);
        if (!this.fixedHeight) {
          // update pageTops cache
          this.pageTops[pn] = t;
          this.pageTops[pn+1] = t + this.getPageHeight(pn);
        }
        if (this.fixedHeight && t0 == t) {
          return;
        }
        // set the page's top
        page.style[this.metrics.position] = t + 'px';
        if (t0) {
          return t0 - t;
        }
      },
      findPage: function(pageNum) {
        return this.$.viewport.querySelector('[page="' + pageNum + '"]');
      },
      scroll: function() {
        this.fire('polymer-list-scroll');
        var info = this.getViewportPageInfo();
        if (!this.pages[0] || this.pages[0].pageNum != info.start) {
          this.prepareUpdate(info);
          this.update(info);
        }
      },
      rafUpdate: function() {
        requestAnimationFrame(function() {
          this.scroll();
          this.rafUpdate();
        }.bind(this));
      },
      update: function(pageInfo) {
        var k = pageInfo.start, n = pageInfo.start+this.numPages, 
            c = pageInfo.center;
        this.pages = [];
        for (; k<n; k++) {
          var p = this.findPage(k) || this.generatePage(k);
          if (p) {
            if (this.retainPages) {
              p.style.display = null;
            }
            this.measurePage(p);
            var d = this.positionPage(p);
            this.pages.push(p);
            // adjust scrollOffset if center page's top has changed
            if (d && k === c) {
              this.scrollOffset -= d;
            }
            // account for async mutation, aka template if and the like.
            Platform.flush();
            // TODO(sorvell): this makes SD polyfill blow up
            /*
            var self = this;
            this.onMutation(p, function() {
              self.update(pageInfo);
            });
            */
          }
        }
        // remove out-of-bounds pages
        this.cleanupPages();
      },
      // extension point for customizing data
      prepareUpdate: function(pageInfo) {},
      forceUpdate: function() {
        var info = this.getViewportPageInfo();
        this.update(info);
      },
      cleanupPages: function() {
        for (var c=this.$.viewport.children, i=c.length-1, p; p=c[i]; i--) {
          if (this.pages.indexOf(p) == -1) {
            if (this.retainPages) {
              p.style.display = 'none';
            } else {
              this.$.viewport.removeChild(p);
            }
          }
        }
      }
    });
  </script>
</polymer-element>