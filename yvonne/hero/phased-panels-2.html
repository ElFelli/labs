<link href="components/polymer/polymer.html" rel="import">
<link href="components/core-selector/core-selector.html" rel="import">
<link href="hero-transition.html" rel="import">

<polymer-element name="phased-panels-2" extends="core-selector">

<template>

  <style>
    :host {
      display: block;
      position: relative;
    }

    /*@polyfill :host > * */
    content::content > * {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    content::content > *:not([top]) * {
      opacity: 0;
    }

    content::content [top] [phase] {
      opacity: 1;
      color: inherit;
      transition: width 20s ease-in, height 20s ease-in, -webkit-transform 20s ease-in, opacity 50s ease-out 18s;
    }

    content::content [phase] {
      color: transparent;
      transition: width 20s ease-in, height 20s ease-in, -webkit-transform 20s ease-in, opacity 30s ease-out;
    }
  </style>

  <shadow></shadow>

</template>

<script>

  Polymer({

    eventDelegates: {
      transitionEnd: 'transitionEnd'
    },

    selected: 0,

    registerCallback: function() {
      this.meta = document.createElement('core-transition');
    },

    getTransition: function() {
      return this.meta.byId('hero-transition');
    },

    applyTransition: function(src, dst) {
      var transition = this.getTransition();
      var heroes = [];
      var h$ = src.querySelectorAll('[hero]');

      for (var i=0, h0; h0=h$[i]; i++) {
        var v = h0.getAttribute('hero');
        var h1 = dst.querySelector('[hero="' + v + '"]');
        if (h1) {
          transition.go(h1, {src: h0});
        }
      }
      /*
      //
      // two passes to reduce layouts: first pass gather information, second pass make changes
      //
      for (var i=0, h0; h0=h$[i]; i++) {
        var v = h0.getAttribute('hero');
        var h1 = dst.querySelector('[hero="' + v + '"]');
        if (h1) {
          heroes.push({
            h0: h0,
            b0: h0.getBoundingClientRect(),
            h1: h1,
            b1: h1.getBoundingClientRect()
          });
        }
      }
      //
      // pass two, modify styles
      //
      heroes.forEach(function(h) {
        //
        console.log(h);
        //
        var dl = h.b1.left - h.b0.left;
        var dt = h.b1.top - h.b0.top;
        var sw = h.b1.width / h.b0.width;
        var sh = h.b1.height / h.b0.height;
        //
        h.scaley = h.h0.hasAttribute('scaley');
        if (!h.scaley && (sw !== 1 || sh !== 1)) {
          sw = sh = 1;
          h.h0.style.width = h.b1.width + 'px';
          h.h0.style.height = h.b1.height + 'px';
        }
        //
        console.log(h);
        console.log('dl, dt:', dl, dt, 'sw, sh:', sw, sh);
        //
        h.h0.style.webkitTransform = 'translate(' + dl + 'px, ' + dt + 'px)' + ' scale(' + sw + ', ' + sh + ')';
        h.h0.style.webkitTransformOrigin = '0 0';
      });
      */
      //
      dst.setAttribute('top', '');
      src.removeAttribute('top');
      //
      // lazy mode 'transitionEnd'
      //
      // this.heroes = heroes;
      this.transitioning = true;
    },

    complete: function() {
      this.heroes.forEach(function(h) {
        h.h0.style.webkitTransform = '';
        if (!h.scaley) {
          h.h0.style.width = h.b0.width + 'px';
          h.h0.style.height = h.b0.height + 'px';
        }
      });
      this.fire('phase-done');
      this.transitioning = false;
    },
    
    transitionEnd: function() {
      if (this.transitioning) {
        this.job('transitionWatch', function() {
          this.complete();
        }, 500);
      }
    },

    selectedItemChanged: function(oldItem) {
      this.super(arguments);
      if (oldItem && this.selectedItem) {
        this.applyTransition(oldItem, this.selectedItem);
      }
    }

  });

</script>

</polymer-element>